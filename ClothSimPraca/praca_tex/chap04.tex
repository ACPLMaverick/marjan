\chapter{Opis aplikacji}
\label{t:praktyka}
	
	\section{Cele i możliwości aplikacji}
	\label{t:praktyka:cel}
	
	% co program ma robić
	
	Na potrzeby niniejszej pracy została stworzona aplikacja prezentująca. Jej działanie realizuje kilka kluczowych celów. Po pierwsze, ma ona za zadanie zaprezentować działanie dwóch omówionych w Rozdziale \ref{t:teoria} modeli symulacji tkanin. Musi pozwalać na porównanie ich pod względem wydajności, stabilności i efektu wizualnego. Wydajność rozumiemy poprzez czas potrzebny na obliczenie jednego kroku symulacji, im mniejszy, tym oczywiście lepiej. Aplikacja informuje o nim użytkownika, wyświetlając stosowną informację w formie tekstowej. Jeśli chodzi o dwa następne czynniki, najlepiej ocenić zachowanie tkaniny wizualnie. A zatem, program rysuje tkaninę w przestrzeni 3D. 
	
	Kluczową kwestią jest tutaj interakcja z innymi obiektami. Aplikacja tworzy wirtualną scenę i umieszcza w niej pewną liczbę podstawowych kształtów geometrycznych, takich jak płaszczyzna, prostopadłościan, bądź sfera. Dzięki temu możemy sprawdzić, jak zachowa się tkanina, wchodząc w kolizje z tymi elementami. Istnieje także możliwość przemieszczania wybranego obiektu (np. sfery) po scenie, co pozwala na tworzenie różnych konfiguracji zderzeń pomiędzy nim a przedmiotem symulacji. Warto wspomnieć, że inne elementy sceny także kolidują ze sobą.
	
	Chcemy także móc porównać prędkość obliczeń modeli tkanin na CPU i GPU oraz zbadać różnicę wydajności GPU urządzenia mobilnego i GPU komputera PC. Aplikacja umożliwia określenie, który z wymienionych wyżej komponentów sprzętowych będzie przetwarzać symulację. Występuje ona także w dwóch wersjach, na dwie podane platformy, pozwalając na dokonanie wszelkich niezbędnych porównań.
	
	Ważną kwestią w naszych rozważaniach są możliwości interakcji z tkaniną, jakie udostępnia nam smartfon. Program prezentuje także tę kwestię, pozwalając przemieszczać fragment symulowanego obiektu przesuwając palec po ekranie dotykowym.
	
	Oprócz tego aplikacja dysponuje sporą ilością ułatwień i udogodnień dla użytkownika. Pozwala na sterowanie kamerą, także przy pomocy ekranu dotykowego, przesuwanie jej po płaszczyźnie XZ, obrót w dowolnym kierunku, przybliżanie i oddalanie. Wyświetlanie w formie tekstu są kluczowe informacje, takie jak wspomniany wcześniej czas trwania obliczeń jednego kroku symulacji, ilość klatek na sekundę czy też aktualnie przetwarzany model tkaniny. Zmienić możemy wiele różnych parametrów tkaniny, opisanych szerzej w Podrozdziale \ref{t:praktyka:symulacja}, oraz tryb rysowania obiektów, jeżeli chcielibyśmy zwrócić uwagę na zachowanie wierzchołków i krawędzi siatki -- tzw. tryb \emph{wireframe}.
	
	\section{Ogólna architektura aplikacji}
	\label{t:praktyka:ogolne}
	
	% z jakich elementów składa się program (Singletony!), jak działają te elementy, jak są ze sobą powiązane,
	% ogólny algorytm pracy całego programu
	
	\myfigure{Najważniejsze elementy aplikacji i wzajemne powiązania.}{figures/pic_4_1.png}{0.4}{pic_4_1}
	
	Na Rysunku \ref{pic_4_1} przedstawione zostały główne komponenty silnika symulacyjnego oraz zależności pomiędzy nimi. Klasy, których nazwy napisano pogrubioną czcionką są singletonami. Strzałka z linią ciągłą oznacza, że klasa A wywołuje funkcje klasy B i działanie B zależy od A. Jeżeli owa strzałka biegnie do nazwy klasy, znaczy to, iż wszystkie jej metody są wywoływane, a jeśli do konkretnej nazwy funkcji -- tylko ona.
	
	Większość singletonów, ale też i ważniejszych klas programu, została napisana zgodnie z prostą architekturą \emph{Initialize -- Run -- Shutdown}. W przypadku sceny, encji, komponentów (klasy \texttt{Component}) i ich pochodnych, funkcja \texttt{Run} została rozbita na oddzielne \texttt{Update} i \texttt{Draw}. Wywoływane są one w głównej pętli programu. Jak można się domyślić, \texttt{Initialize} i \texttt{Shutdown} uruchamiamy przy starcie i wyłączaniu aplikacji. Takie podejście zapewnia dużą przejrzystość w strukturze wywołań funkcji silnika.
	
	Podstawowym elementem spajającym działanie całego silnika jest klasa \texttt{System}. Odpowiada ona za inicjalizację wszystkich singletonów -- menedżerów, ich aktualizację w głównej pętli programu, zwalnianie pamięci przy wyłączaniu aplikacji oraz za obsługę zdarzeń przychodzących z systemu Android. W jej gestii leży uśpienie i wznowienie programu, gdy takie żądanie zostanie wywołane. Przechowuje także aktualnie wczytaną scenę (klasa \texttt{Scene}) i w każdej klatce wywołuje jej metodę \texttt{Update()}, odświeżając stan wszystkich encji. Także tutaj znajduje się referencja do struktury \texttt{Engine}. Ta struktura jest utrzymywana \emph{stricte} na potrzeby komunikacji z Androidem i dzięki niej mamy dostęp do wszystkich danych, jakie dostajemy od systemu. Wśród nich są m.in. rozmiary ekranu, wskaźnik do androidowej struktury \texttt{android\_app}, gdzie przechowywane są te dane, oraz identyfikatory kontekstu graficznego, powierzchni rysowania i wyświetlacza, niezbędne bibliotece EGL w inicjalizacji OpenGL.
	
	Drugim najważniejszym singletonem systemu jest klasa \texttt{Renderer}. Razem z klasami pochodnymi \texttt{MeshGL} skupia w sobie wszystkie funkcjonalności dotyczące renderingu grafiki 3D. Do jego odpowiedzialności należy inicjalizacja bibliotek EGL oraz OpenGL, odpowiedni wybór parametrów okna, utworzenie powierzchni rysowania oraz kontekstu. Następnym krokiem jest załadowanie wszystkich potrzebnych shaderów i ustawienie wybranych parametrów OpenGL. Do tych ostatnich zaliczamy m.in. wybór koloru, jakim czyszczony jest bufor ramki, włączenie testu głębokości, odcinania tylnych ścianek wielokątów, uruchomienie i ustawienie funkcji mieszania przezroczystości. Oczywiście przy wywołaniu metody \texttt{Shutdown} usuwane są wszelkie dane związane z renderingiem oraz niszczone są wymienione wyżej elementy. Jego funkcja \texttt{Run} zawiera przede wszystkim obsługę zmiany rozmiaru ekranu, a co za tym idzie, parametrów okna i powierzchni rysowania, obsługę przełączania trybu wyświetlania obiektów, a wreszcie -- renderingu elementów sceny oraz interfejsu użytkownika poprzez wywołanie metod \texttt{Draw} i \texttt{DrawGUI} obiektu typu \texttt{Scene}. Założeniem projektowym dla tej klasy była enkapsulacja większości wywołań funkcji OpenGL, tak, by kod renderingu dało się łatwo wymienić na inny. W związku z tym, klasa \texttt{Renderer} posiada także specjalistyczne funkcje do wczytywania shaderów, kerneli i tekstur oraz zwalniania pamięci po tych zasobach graficznych. Warto wspomnieć o tym, że z projektowego punktu widzenia, w aplikacji rozróżniamy pomiędzy shaderem (używanym do rysowania obiektów) a kernelem (używanym do obliczeń GPGPU, w transformacyjnym sprzężeniu zwrotnym), chociaż z punktu widzenia ich wczytywania, są \emph{de facto} tym samym -- kodem GLSL, który przekształcamy w tzw. \emph{program} OpenGL. 
	
	Kluczowym dla działania symulacji komponentem jest klasa \texttt{Timer}. Jak sama nazwa wskazuje, zajmuje się ona wszystkimi czynnościami dotyczącymi zliczania czasu. Do pobrania aktualnego \(t\) użyto funkcji \texttt{clock\_gettime}, zawartej w bibliotece \emph{time.h}. Oferuje ona dokładność co do nanosekund, jednak na potrzeby naszego systemu wszelkie wielkości czasowe są przechowywane w formacie milisekund -- jest to wystarczająca precyzja. \texttt{Timer} udostępnia następujące dane: czas całkowity, który upłynął od startu programu, czas, jaki mija pomiędzy kolejnymi krokami głównej pętli, \(\delta t \), tzw. \emph{delta time}, ilość klatek na sekundę (FPS -- \emph{Frames Per Second}), będąca odwrotnością \(\delta t \), ilość kroków głównej pętli programu od początku jego działania oraz tzw. \emph{fixed delta time}, czyli stała, uśredniona wartość czasu pomiędzy krokami pętli, obliczona na podstawie ich pierwszych dziesięciu. Klasa \texttt{Timer} posiada też funkcjonalność zapisywania stempli czasowych, umożliwiając łatwe odmierzanie czasu pomiędzy pewnymi wydarzeniami.
	
	\texttt{ResourceManager} jest odpowiedzialny za zarządzanie zasobami symulacji. W naszym przypadku ich rolę pełnią tylko tekstury, shadery i kernele. Kluczową kwestią tutaj jest działanie funkcji \texttt{Load...}. Zasoby są trzymane w przeznaczonych do tego kolekcjach. Wywołując tę funkcję, sprawdzana jest najpierw odpowiednia kolekcja na obecność żądanego zasobu. Jeżeli takowy istnieje, jest od razu zwracany. Jeśli go nie ma, dopiero wtedy rozpoczyna się proces załadowania go z pliku. Dzięki takiemu podejściu w żadnym miejscu kodu nie musimy martwić się o to, czy wczytaliśmy zasób, czy jeszcze nie.
	
	Do obowiązków klasy \texttt{PhysicsManager} należy tak naprawdę tylko rozwiązywanie kolizji, przechowywanie wszelkich danych z tym związanych, tj. klas kolizyjnych, tzw. \emph{colliderów}, pochodnych klasy \texttt{Collider}. Omawiany singleton zawiera także aktualny wektor grawitacji. W celach optymalizacyjnych, kolizje nie są sprawdzane na zasadzie ``każdy obiekt z każdym'', ale tylko dla tych encji, które w danej klatce zmieniły swoje położenie. Wyjątkiem jest sama tkanina -- dla niej kolizje rozwiązywane są w każdym kroku symulacji i poza klasą \texttt{PhysicsManager}, z racji konieczności wykonywania tych obliczeń na GPU było to najwygodniejszym podejściem.
	
	Ostatnimi omawianymi singletonami są \texttt{InputManager} oraz \texttt{InputHandler}, który go opakowuje. Owe dwie klasy są ze sobą nierozerwalnie związane. Pierwsza zapewnia niskopoziomową obsługę wszelkich zdarzeń pochodzących z urządzeń wskazujących oraz wyciągnięcie z nich informacji o np. wciśniętych klawiszach, o ile to możliwe. Dane, które zawarte są w owych zdarzeniach zostają sformułowane i udostępnione w postaci wygodnych elementów, tj. zmiennych logicznych, umożliwiających przykładowo sprawdzenie, czy aktualnie ekran dotykowy jest wciśnięty, oraz wektorów dwuwymiarowych odzwierciedlających pozycję wciśnięcia oraz kierunek przesunięcia palca, bądź palców po ekranie. Przeciągnięcie dwoma palcami \texttt{InputManager} także obsługuje, tak samo jak gest ``uszczypnięcia'', czyli tzw. \emph{pinch}. Z kolei \texttt{InputHandler} przekuwa informacje o stanie urządzeń wejściowych na dane o możliwości wykonania konkretnych akcji systemu. Przykładowo, jego funkcja \texttt{GetCameraMovementVector} odnosi się do metody \texttt{GetDoubleTouchDirection} \texttt{InputManagera}. Takie podejście pozwala nam na szybką zmianę sterowania systemem bez potrzeby przerabiania wszystkich zaangażowanych w to komponentów, a jedynie zmieniając implementację funkcji klasy \texttt{InputHandler}. 
	
	\section{Budowa i działanie silnika dla wizualizacji i zarządzania symulacją}
	\label{t:praktyka:silnik}
	
	\myfigure{Architektura przykładowej encji systemu.}{figures/pic_4_2.png}{0.34}{pic_4_2}
	
		\subsection{Encje systemu}
		\label{t:praktyka:silnik:komponent}
		
		% model komponentowy dla encji systemu
		% Scene, SimObject, Component, Transform, Collider
		% symulator tkaniny jako komponent
		
		Dupa dupa.
		
		\subsection{Komunikacja z Androidem}
		\label{t:praktyka:silnik:andro}
		
		% incjalizacja
		% zdarzenia systemu (klasa System)
		% zdarzenia interfejsu (InputManager)
		
		\subsection{Rendering}
		\label{t:praktyka:silnik:render}
		
		% inicjalizacja renderera
		% pętla renderingu
		% klasa MeshGL i podklasy - inicjalizacja i metoda rysowania
		% obsługiwane shadery, tryby rysowania
		
		\subsection{Interfejs użytkownika}
		\label{t:praktyka:silnik:gui}
		
		% niezbędność GUI -- podejmowanie akcji, informowanie użytkownika
		% InputManager i InputHandler -- co udostępniają, jak są powiązane
		% komponent GUIController -- kontrola ekranu dotykiem
		% elementy GUI i ich role w systemie, hierarchiczność, dopasowanie do ekranu
	
	
	\section{Budowa i działanie symulatora tkaniny}
	\label{t:praktyka:symulacja}
	
		\subsection{Obliczenia ruchu tkaniny}
		\label{t:praktyka:symulacja:ruch}
		
		\subsection{Rozwiązywanie kolizji}
		\label{t:praktyka:symulacja:kolizje}
		
		\subsection{Interakcja z użytkownikiem}
		\label{t:praktyka:symulacja:interakcja}
		
		\subsection{Przeliczenie wektorów normalnych}
		\label{t:praktyka:symulacja:normalne}
	
	
	%\section{Budowa i działanie symulatora tkaniny na platformie Windows}	% - ni ma CUDY, będzie to samo
	%\label{t:praktyka:symulacjapc}
	
