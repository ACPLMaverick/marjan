\chapter{Podsumowanie i wnioski}
\label{t:wnioski}

	\section{Porównanie obu modeli symulacji}
	\label{t:wnioski:porownanie}
	
	% trudność pojęciowa -- ms łatwe, pb trudne
	% trudność implementacji -- bardzo podobna w obecnej formie ale PB elastyczniejsze, udostępnia więcej możl.
	% wydajność -- podobna, dużą część zajmuje wykrywanie kolizji
	% stabilność - PB wins, spada wraz ze wzrostem ilości krawędzi i elastyczności
	% ładność - PB lekko wins, można było bawić się różnymi paramterami dla różnych sprężyn, kolizje suck, szybkość i zabawa delta t
	% zastosowanie w praktyce -- MS dla prostych, PB dla każdych, konieczność lepszych kolizji
	
	Porównania omówionych w niniejszej pracy modeli symulacji tkanin należy dokonać z~uwzględnieniem wielu różnych czynników, tak aby na koniec móc jasno określić, który nadaje się lepiej do zastosowań praktycznych. 
	
	Aby móc zaimplementować którąkolwiek z~metod, programista musi wpierw dobrze zrozumieć jej działanie. Podstawy teoretyczne modelu masy na sprężynie są dużo prostsze, jako że oparto go o~łatwy do wyobrażenia system punktów masy połączonych sprężynami, których parametry, takie jak np. współczynnik sprężystości, wpływają na zachowanie tkaniny. Całość działa, wykorzystując znane z~podstaw fizyki prawo Hooke'a. Sprawia to, że nawet początkującemu programiście, nieobeznanemu z~meandrami matematyki, łatwo przyjdzie pojęcie i~przedstawienie sobie wizualnie tej metody. Z~kolei model oparty na pozycji wykorzystuje do swoich obliczeń dużo bardziej skomplikowane pojęcia i~może nastręczyć takiej osobie niemałych trudności.
	
	Sytuacja wygląda inaczej, jeśli weźmie się pod uwagę poziom trudności implementacji. Tworzenie omawianej aplikacji wykazało, że jest on niemal identyczny dla obu modeli symulacji. Każdy z~nich da się zaprogramować tak, aby korzystał z~tych samych danych oraz funkcji, różniąc się jedynie obliczeniami wykonywanymi przy konkretnych sprężynach bądź ogranicznikach. Obie techniki podczas swojego przetwarzania wykorzystują różnicę pomiędzy odległością spoczynkową a~aktualną między wierzchołkami. Niebotyczny wpływ na taki stan rzeczy miała na pewno decyzja o~nieużywaniu ograniczników zginania w metodzie opartej na pozycji. Zaimplementowanie wszystkich rozwiązań opisanych w~\cite{posbased} na pewno zmieniłoby stan rzeczy na korzyść modelu masy na sprężynie. Należy jednak zaznaczyć, że system ograniczników zapewnia dużo większy wachlarz zastosowań, umożliwiając wykorzystanie ich nie tylko do obliczeń ruchu, ale też i~np. rozwiązywania kolizji. Dołożono starań, by wyodrębnić jak największą część wspólną obliczeń dla obu modeli, z~chęci minimalizacji redundancji kodu i~dzięki temu do detekcji kolizji, reakcji na sygnał od użytkownika oraz przeliczenia normalnych używany są te same instrukcje.
	
	W~najważniejszej kwestii, czyli wydajności, okazuje się, iż obie metody także wykazują się podobnymi rezultatami, z~bardzo niewielkim zwycięstwem modelu opartego na pozycji w~implementacjach CPU. Nie można było dokładnie zbadać różnic w przypadku GPU, jako że objętość buforów jednorodnych nie pozwoliła na wygenerowanie tkaniny o~tak dużej liczbie wierzchołków, by czas wykonania wzbił się wyżej niż 20 ms. Biorąc pod uwagę duże podobieństwo samego kodu, należy przypuszczać, że także byłaby ona niewielka. Podczas testów zauważono, iż znaczną część czasu obliczeń zajmuje część algorytmu odpowiedzialna za rozwiązywanie kolizji. Może to wynikać z~faktu użycia instrukcji warunkowych w~kodzie wykonywanym na GPU. Większa liczba obiektów w~scenie wiązałaby się na pewno z~koniecznością głębszej optymalizacji tego zagadnienia, na przykład ograniczając liczbę potencjalnych encji mogących wejść w kolizje z~tkaniną jeszcze na poziomie CPU.
	
	Oba wykorzystane modele symulacji charakteryzuje pewna, zależna od parametrów, niestabilność, jednak jest ona dużo większa w~przypadku modelu masy na sprężynie. Niewątpliwe zaletą okazuje się fakt, iż w~skład wzoru, na podstawie którego obliczane są siły działające na wierzchołek wchodzi komponent odpowiedzialny za tłumienie drgań, a~użytkownik może go dowolnie regulować, w~ten sposób mając na nie wpływ. Tę metodę charakteryzuje wzrost oscylacji siatki wraz ze wzrostem współczynnika elastyczności. Mają one postać małych, acz szybkich wibracji na całej powierzchni tkaniny. Z~kolei dla dużych liczb krawędzi potrzeba dużej sztywności, aby zachować odpowiedni kształt, co jeszcze bardziej powiększa problem. Duże drgania z~pozoru sprawiają wrażenie, że utrzymują się na stałym poziomie, jednak przy jakiejkolwiek nagłej zmianie położenia wierzchołków, np. przy kolizji, mogą doprowadzić do nagłego ,,wybuchu'' symulacji, co jest w~praktyce niedopuszczalne. W~przypadku modelu masy na sprężynie także zaobserwowano zależność pomiędzy wzrostem gęstości siatki, elastyczności a~utratą stabilności. Jednakże ta metoda w każdym momencie i~tak jest stabilniejsza niż jej rywalka, co pokazały wyniki zaprezentowane w~rozdziale \ref{t:wyniki:stabilnosc}. Drgania są tutaj dużo wolniejsze i~mają postać delikatnego, niekontrolowanego falowania, co dużo mniej zwraca uwagę użytkownika. Dużym plusem jest brak występowania efektu ,,eksplozji'', niezależnie od ustawionych parametrów. Efekt ten udało się uzyskać poprzez pewnego rodzaju ,,trik'' implementacyjny -- pozycja wierzchołka przesyłana do funkcji obliczającej ogranicznik jest aktualizowana na bieżąco tylko w~ramach sąsiadów położonych w jednej linii. Minusem modelu opartego na pozycji w~niniejszej implementacji jest tendencja do blokowania się tkaniny samej na sobie, przy dużych współczynnikach elastyczności.
	
	Obie metody symulacji tkaniny generują pożądany efekt graficzny, czyli realistyczne zagięcia i~zmarszczki tkaniny oraz jej charakterystyczne ułożenie na obiekcie. Ich jakość jest minimalnie lepsza dla modelu opartego na pozycji, m.~in. z~racji nie występowania tam drobnych drgań oraz większej responsywności na zmiany współczynnika sztywności. Należy zauważyć, że np. na potrzeby gier w~wielu przypadkach nie potrzeba szczegółowo odwzorowanych detali tkanin, te można uzyskać przy pomocy map normalnych, a~po prostu przybliżonej symulacji ich ruchu. Dwie omawiane metody cechuje wierne odwzorowanie tego aspektu nawet dla małej liczby krawędzi. Z~kolei gdy wziąć pod uwagę gęste siatki, nasuwa się problem związany z~szybkością animacji. Duża liczba wierzchołków wymaga odpowiedniego współczynnika elastyczności, a~ten spowalnia przesuwanie tkaniny. Widać to szczególnie w~modelu opartym na pozycji. Rozwiązaniem mogłoby być bardziej dokładne dopasowanie współczynników bądź zwiększenie parametru \( \delta t \), niezmiennego w~omawianej symulacji. Poprawę sytuacji prawdopodobnie można też uzyskać poprzez ustawianie innych parametrów sztywności dla każdej z~grup sprężyn, bądź ograniczników (tj. równoległych do krawędzi tkaniny, leżących po przekątnej oraz takich jak pierwsze, lecz położonych o jedną pozycję dalej). Dużym minusem w~kwestii efektu wizualnego okazała się zastosowana metoda detekcji kolizji. Nie rozwiązuje ona w~satysfakcjonujący sposób kolizji wewnętrznych i~często występują błędy kolizji zewnętrznych, np. w~przypadku opadnięcia tkaniny na prostopadłościan. Aby naprawić problem, należałoby zaimplementować inną technikę. Jednak na pewno wiązałby się z~tym ubytek w wydajności i~tak najcięższego obliczeniowo komponentu symulacji.
	
	Biorąc pod uwagę wszystkie wymienione powyżej czynniki, można uznać iż do zastosowań praktycznych model oparty na pozycji nadaje się bardziej. Lepiej radzi on sobie z~dużymi liczbami wierzchołków, cechuje go względna stabilność i~jest minimalnie wydajniejszy. Niezależnie od pożądanej jakości wizualizacji, w~większości przypadków parametry da się ustalić tak, by uzyskać dobry efekt graficzny. Nie znaczy to jednak, że w~obecnej implementacji jest on wolny od wad, a różnice między metodami zanikają wraz ze spadkiem gęstości siatki -- wtedy i~model oparty na pozycji, i~masy na sprężynie cechują bardzo podobny wygląd oraz zachowanie.
	
	\section{Porównanie implementacji CPU i GPU smartfona}
	\label{t:wnioski:cpu_vs_gpu}
	
	% nieporównywalne zwycięstwo na GPU, idealne do tego problemu, stabilność wydajności, wada blokady fps, CPU tylko do bardzo prostych tkanin bądź słabych GPU na mobilnych, bądź gdy dysponuje się starym api, albo w 2d
	% implementacja CPU łatwiejsza, GPU narzuca ograniczenia i sposób wykonywania obliczeń
	
	Kolejnym aspektem niniejszej pracy było wykazanie wyższości zastosowania kart graficznych urządzeń mobilnych nad zastosowaniem procesorów tychże w~dziedzinie symulacji fizycznej tkanin. Testy zaprezentowane w rozdziale \ref{t:wyniki} jasno wskazują zwycięzcę tego porównania pod względem wydajności. GPU są wielokrotnie szybsze od CPU podczas obliczeń zagadnień mogących być przetwarzanymi równolegle, a~takim właśnie jest omawiany problem. Rozłożenie pracy nad wierzchołkami siatki tkaniny na poszczególne jednostki przetwarzające GPU to wręcz intuicyjne, a~zarazem skuteczne i~wydajne rozwiązanie pomimo występującej tu redundancji. Zarejestrowana szybkość działania okazuje się być taka sama, niezależnie od ilości danych, czego nie można powiedzieć o~implementacjach CPU, gdzie maleje ona liniowo. Podział na wątki robocze zwiększa ją dwukrotnie, co trochę poprawia sytuację, jednak w~przypadku szczegółowych tkanin i~tak wydajność jest za niska. Z~kolei na GPU zaobserwowano blokowanie liczby renderowanych klatek na sekundę do wartości zgodnej z odświeżaniem ekranu przez transformacyjne sprzężenie zwrotne. Jest to wada, nie pozwalająca w pełni ocenić wydajności i~blokująca prędkość działania aplikacji, jeśli nie dba się o~występowanie efektu ,,tearingu'', a~chce uzyskać jak najszybsze działanie. Problem być może rozwiązałaby zmiana testowego sprzętu na inny, bądź wykorzystanie innego API do obliczeń GPGPU, co niestety też oznacza konieczność wymiany.
	
	Wszystko to nie zmienia jednak faktu, iż implementacja CPU także ma swoje zastosowania i~zalety. Użycie jej jest konieczne w sytuacji, gdy urządzenie nie obsługuje wersji OpenGL ES 3.0, ani żadnej z specjalistycznych API, jak OpenCL. Możliwe, że uzyskałaby ona przewagę wydajnościową w~sytuacji, gdy platforma testowa dysponowałaby GPU z~bardzo niskiej półki. Da się ją także z~pewnością zastosować, gdy zbiorem danych jest jedynie bardzo niewielka liczba wierzchołków, bądź jeśli wybrano animację tylko w~przestrzeni 2D. Należy także zaznaczyć, że symulację tkanin dużo łatwiej zaimplementować na CPU, gdyż nie wymaga to głębszej znajomości API graficznego ani żadnych innych oraz tworzenia dość złożonego sterowania buforami, zmiennymi jednorodnymi, programami i~transformacyjnym sprzężeniem zwrotnym.
	
	\section{Porównanie implementacji GPU smartfona i GPU PC}
	\label{t:wnioski:andro_vs_pc}
	
	% olbrzymia różnica w wydajności i brak blokady FPS ale do tkanin występujących w małych ilościach bądź do prostych tkanin wielokrotnie powielanych GPU mobajla nadaje się bez problemu. Problemem jest też mniejsza ilość pamięci wideo i przegrzewanie się, oraz krótkość baterii.
	% implementacja PC łatwiejsza -- nowsze technologie, przystosowane do GPGPU, mobajle są kilka lat wstecz
	
	W rozdziale \ref{t:technologie} przewidywano, że wydajność urządzeń mobilnych w~omawianym zagadnieniu będzie wielokrotnie niższa, niż komputerów klasy PC. Stworzenie dwóch wersji aplikacji, jednej na platformę Android, drugiej -- na platformę Windows pozwoliło potwierdzić to przypuszczenie. Różnica szybkości działania jest ok. 300-krotna, w~dodatku na PC znika problem dotyczący blokady liczby renderowanych klatek na sekundę. Pozostaje więc na tej podstawie odpowiedzieć na fundamentalne pytanie: czy implementacja symulacji tkanin na urządzeniach mobilnych ma w~ogóle sens, jeśli do dyspozycji są dużo szybsze komputery stacjonarne? Okazuje się, że tak, aczkolwiek na trochę mniejszą skalę. O~ile smartfon z użyciem GPU może bezproblemowo animować tkaninę o naprawdę gęstej siatce, wystarczającej do odwzorowania większości szczegółów, to tę platformę dręczy kilka istotnych problemów. 
	
	Pierwszym jest wspominany już wielokrotnie brak buforów teksturowych na części urządzeń, co ogranicza maksymalną możliwą do uzyskania jakość. Pamiętać należy także o~ogólnie niższej ilości pamięci karty graficznej, wprowadzającej kolejne limity w~tej kwestii. Symulacja tkanin mimo wszystko bardzo mocno wykorzystuje tu możliwości sprzętowe, doprowadzając do przegrzewania się urządzenia. Prowadzi to do redukcji wydajności przez system operacyjny, co z~kolei skutkuje znacznym wydłużeniem przetwarzania i~miało wpływ na wyniki testów w~rozdziale \ref{t:wyniki:czas_wykonania}. Tworząc aplikacje, które cechuje znaczne zapotrzebowanie na moc obliczeniową należy o~tym fakcie pamiętać. To, że program początkowo działa bez zarzutu nie znaczy, iż za parę minut nie może zwolnić, gdy temperatura osiągnie wysokie wartości. Intensywna eksploatacja zasobów sprzętowych skutkuje także szybkim zużyciem baterii, co nie pozostaje bez znaczenia dla użytkownika końcowego i~powinno być istotne podczas projektowania aplikacji.
	
	Trzeba także wspomnieć o~różnicach w~API dostępnych na obu platformach. W przypadku PC, poczyniono ostatnimi czasy duże kroki w~celu udostępnienia programistom kart graficznych jako urządzeń do obliczeń ogólnego przeznaczenia. Jest tu dostępne wiodące w~tej dziedzinie API, czyli CUDA, cechujące się bardzo prostą obsługą i~dużą elastycznością. Ponadto także twórcy oprogramowania graficznego starali się udostępnić te funkcje, wprowadzając Compute Shadery. Implementacja symulacji tkanin z~ich użyciem byłaby zdecydowanie dużo łatwiejsza. Należy pamiętać, że wsparcie dla GPGPU na urządzeniach mobilnych nie jest tak zaawansowane, jak na PC i~w~efekcie programista musi się poruszać w oprogramowaniu starszej o~kilka lat generacji. Mimo to symulację można tu stworzyć, choć nastręcza to więcej trudności.
	
	%\section{Wpływ symulacji tkaniny na całość działania silnika}
	%\label{t:wnioski:wplyw}
	
	% Lepiej pisać aplikacje zorientowane na szczegółowe tkaniny, jako elementy tła mogą być niepotrzebnym obciążeniem, GPU - niewielki udział w procesie obliczeniowym lecz wraz ilością tkanin może on wzrastać, CPU - nie ma sensu
	
	
	
	%\section{Podsumowanie}
	%\label{t:wnioski:podsumowanie}
	
	% implementacja na urządzeniach mobilnych ma sens i da się wykorzystać do unikalnych zastosowań
	% wydajnościowo można generować szczegółowe tkaniny, ale tylko na GPU
	% implementacja GPU wymaga nowych api opengl bądź opencl / renderscript ale niekoniecznie telefonów z najwyższej półki
	% sensowną do użycia w praktyce wydaje się być metoda oparta na pozycji

