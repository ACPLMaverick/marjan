\chapter{Budowa i działanie symulatora tkaniny}
\label{t:symulacja}

	\section{Założenia projektowe}
	\label{t:symulacja:zalozenia}
	
	%cel działania, możliwości, użycie pamięci, szybciej a więcej pamięci, przystosowanie do GPU, tryby, uproszczony algorytm -- podział na etapy, różnice między implementacjami
	
	Całość funkcjonalności dotyczących symulacji tkaniny skupiono w klasie \texttt{ClothSimulator}. Dziedziczy ona po typie abstrakcyjnym \texttt{Component}. Za sprawą tego bardzo dobrze komponuje się z architekturą silnika, bez problemu możemy ją dodać do dowolnego \texttt{SimObjectu} oraz wielokrotnie powielić, a także zarządzać jej działaniem poprzez zmienną włączającą bądź wyłączającą.
	
	W prezentowanej aplikacji został umieszczony jednak tylko jeden \texttt{ClothSimulator}, aby uprościć działanie i ułatwić pomiary testowe. Za cel części praktycznej pracy postawiono sobie możliwość zasymulowania zachowania pojedynczej tkaniny o prostokątnym kształcie, zawieszonej sztywno w powietrzu za dwa sąsiednie narożniki, poddającej się działaniom sił grawitacji oporu powietrza i wchodzącej w interakcje z obiektami sceny oraz sygnałami od użytkownika, za pośrednictwem ekranu dotykowego smartfona. Symulacja miała udostępniać opcję bycia obliczaną dwoma metodami -- masy na sprężynie i bazującą na pozycji oraz trzema sposobami -- przy użyciu GPU, sekwencyjnie na CPU oraz współbieżnie na CPU, z wykorzystaniem czterech wątków roboczych. Użytkownikowi pozwolono na zmianę istotnych parametrów symulacji poprzez ich wybór z ustalonego zakresu. Wszystkie wymienione wyżej cele zostały zrealizowane. Przeznaczeniem symulatora jest jednak nie tylko wizualizacja, ale też i udostępnienie możliwości oceny modeli tkanin oraz ich implementacji pod kątem wydajności, dlatego program wyświetla informacje o czasie trwania pojedynczego kroku symulacji, a także o całościowym okresie jednego przebiegu pętli głównej programu. 
	
	\section{Wydajność a użycie pamięci}
	\label{t:symulacja:wydajnoscpamiec}
	
	Jako, że flagowym celem niniejszej pracy było zaimplementowanie symulacji z użyciem GPU, nadrzędne założenie przy projektowaniu to jak największe przyspieszenie przetwarzania kosztem większego użycia pamięci. Wszystkie możliwe dane i czynniki zostają obliczone podczas inicjalizacji symulatora, a wyniki są po prostu przesyłane do odpowiednich funkcji w trakcie działania programu. Wpasowuje się to doskonale w metodykę programowania GPU, do której się dostosowujemy, za sprawą chociażby minimalizacji ilości instrukcji warunkowych oraz uniknięcia obliczeń, które niepotrzebnie byłyby wykonywane dla każdego wierzchołka tkaniny, a mogą przecież zostać przetworzone tylko raz. 
	
	Przykładowo, sprawdzając sąsiadów wierzchołka, musimy obliczyć ich identyfikatory (tzn. poznać, które to konkretnie są wierzchołki) oraz zawsze mieć pewność, iż takowy istnieje -- nie wszystkie mają czterech sąsiadów, a dokładnie -- nie posiadają tylu te znajdujące się na zewnętrznych krawędziach siatki. Problem zostaje rozwiązany, gdy każdemu wierzchołkowi przypiszemy ustalone przy starcie komponentu zarówno listę identyfikatorów oraz mnożników, które wynoszą 1 gdy sąsiad istnieje, bądź 0 gdy go nie ma, i w tym przypadku obliczona siła bądź przesunięcie nie biorą udziału w dalszym przetwarzaniu. Eliminujemy także konieczność użycia instrukcji warunkowej, co dodatkowo poprawia nam wydajność. 
	
	Niestety, takie podejście zwiększa zużycie pamięci. Jak można się domyślić, jest ono proporcjonalne do ustalonej przez użytkownika gęstości siatki tkaniny. Ponadto, wszystkie wierzchołki wraz z ich parametrami są przechowywane dwukrotnie, z racji konieczności posiadania informacji o pozycjach poprzednich, dla całkowania Verleta (wzór (2.9), Rozdział \ref{t:teoria:analiza:masa}). W przypadku, gdy wybranym trybem symulacji jest tryb GPU, wszystkie te dane zostają dodatkowo skopiowane do pamięci karty graficznej. Dochodzą jeszcze do tego parametry pomocnicze, takie jak wymienione wyżej listy identyfikatorów sąsiadów. Rozważmy przykład, gdzie ustaliliśmy siatkę o \(m \times n\) dodatkowych krawędzi bocznych. Ilość wierzchołków będzie wynosić \( (m + 2)(n + 2) \). Z każdym z nich wiążą się następujące atrybuty:
	
	\begin{itemize}
		\item Pozycja (16 B),
		\item Koordynat teksturowania (8 B),
		\item Wektor normalny (16 B),
		\item Kolor (16 B),
		\item Koordynat barycentryczny (16 B),
		\item Indeks (4 B).
	\end{itemize}
	
	Wielkość niektórych elementów została sztucznie zwiększona tak, aby była wielokrotnością 4 B. Dzięki temu dane zostały poprawnie ułożone w buforach jednorodnych, omawianych w Rozdziale \ref{t:technologie:narzedzia:bufory}. W sumie jeden wierzchołek zajmuje 152 B pamięci -- bierzemy pod uwagę podwójne występowanie. Należy jednak pamiętać jeszcze o właściwych dla symulacji parametrach, opisanych w podrozdziale \ref{t:symulacja:dzialanie:parametry}, z których część jest przypisywana każdemu wierzchołkowi oddzielnie. Dodają one do naszych obliczeń kolejne 128 B. W sumie cała tkanina wraz z parametrami waży:
	
	\begin{equation}
	s = 280(m + 2)(n + 2) + 32 \ .
	\end{equation} 
	
	Ostatnia wartość wynika z konieczności przechowywania pojedynczego wektora początkowych odległości między danym a sąsiednimi wierzchołkami, takich samych dla każdego, gdyż rozważamy jednorodną prostokątną siatkę, oraz wektora przesunięcia palca użytkownika po ekranie dotykowym, kluczowego dla realizacji opisanej w podrozdziale \ref{t:symulacja:dzialanie:interakcja} interakcji. Przykładowo, dla gęstej, jak na warunki urządzenia mobilnego, siatki \( 98 \times 98 \) krawędzi, zajętość pamięci wynosi 2800032 B, czyli ok. 2,7 MiB. Jest to spora jak na jeden obiekt logiczny, lecz w żadnym wypadku nie krytyczna ilość dla testowego smartfona, wyposażonego w 2 GB RAM. Oczywiście w naszych obliczeniach nie bierzemy pod uwagę rozmaitych zmiennych pomocniczych dla symulatora tkanin, identyfikatorów buforów i struktur GPU oraz zapisanych wartości parametrów, jednak ich rozmiar jest tu pomijalnie mały.
	
	\section{Zasada działania}
	\label{t:symulacja:dzialanie}
	
		\subsection{Ogólny algorytm}
		\label{t:symulacja:dzialanie:algorytm}
		
		Algorytm działania symulacji jest taki sam dla wszystkich trzech obsługiwanych implementacji -- GPU, CPU i CPU na 4 wątkach. Różnice oczywiście pojawiają się tylko w wywołaniach funkcji. 
		
		Dla pierwszego przypadku w każdym kroku należy przeprowadzić przypisanie GPU odpowiednich tablic atrybutów wierzchołków, które zawierają niezbędne symulacji dane. Następnie nakazujemy OpenGL używać programu dokonującego obliczeń, ustawiamy wszystkie zmienne jednorodne, wiążemy bufory jednorodne i uruchamiamy transformacyjne sprzężenie zwrotne. Wywołanie \texttt{glDrawArrays} rozpoczyna obliczenia. 
		
		W przypadku CPU sprawa jest dużo prostsza, jako, że wszystkie dane i tablice, na których pracujemy są już zainicjalizowane. Możemy od razu przystąpić do działania. Sytuacja komplikuje się, gdy chcemy skorzystać z wielowątkowości. W tej metodzie rozłożono pracę na cztery wątki robocze, z racji tego, iż urządzenie dysponuje czterema fizycznymi jednostkami przetwarzającymi. Algorytm podziału jest prosty -- liczbę wierzchołków dopełniamy do liczby podzielnej bez reszty przez 4 i dzielimy ją na cztery równe zakresy, przy czym koniec ostatniego z zakresów jest oczywiście tą ``prawdziwą'' liczbą wierzchołków. Do synchronizacji użyto muteksów i licznika wątków, które zakończyły pracę. Działaniem wątków roboczych zarządza, rzecz jasna, wątek główny. Każdy z tych pierwszych jest uśpiony na muteksie, dopóki nie nadejdzie wywołanie funkcji \texttt{Update} symulatora. Wtedy zostają one obudzone i rozpoczynają obliczenia. Po ich zakończeniu podnoszą licznik i czekają na następnym muteksie. Główny wątek z kolei czeka, aż licznik osiągnie wymaganą wartość i odblokowuje następny etap obliczeń.
		
		Cały proces podzielono na trzy oddzielne etapy, omówione dalej. Pierwszy to obliczenia ruchu tkaniny, zgodnie z przyjętym modelem symulacji, drugi -- rozwiązywanie kolizji oraz zaaplikowanie ruchu tkaniny wynikłego z interakcji użytkownika. Te dwie kwestie opisano w oddzielnych podrozdziałach, jednak z punktu widzenia implementacji wchodzą one w skład jednego etapu. Ostatnim jest przeliczenie wektorów normalnych. Po dwóch pierwszych etapach następuje zamiana identyfikatorów struktury danych wejściowych z strukturą danych wyjściowych, zastosowano tu tzw. metodę ping--pongową. Gdybyśmy tego nie robili, spowodowałoby to szybki ``wybuch'' symulacji, jako że obliczenia na danym wierzchołku mogłyby pobierać część danych już w danym kroku zaktualizowanych, a część nie. W przypadku obu implementacji na CPU po zakończeniu kroku przetwarzania należy jeszcze przesłać nowe dane o pozycjach i wektorach normalnych wierzchołków do GPU, w celu umożliwienia ich narysowania. Dzieje się to przy pomocy funkcji \texttt{glBufferSubData}.
		
		Poniżej podano Algorytmy \ref{alg_5_1}, \ref{alg_5_2} i \ref{alg_5_3}, osobno dla każdej z implementacji. Dzięki temu możemy zaobserwować kluczowe różnice w tych podejściach, a także ocenić skomplikowanie kodu.
		
		\begin{algorithm}
			\label{alg_5_1}
			\caption{Symulacja na GPU.}	
			
			Inicjalizuj parametry tkaniny.
			
			Utwórz identyfikatory buforów GPU.
			
			Przypisz istniejące już identyfikatory buforów siatki modelu tkaniny do odpowiednich identyfikatorów w klasie symulacji.
			
			Utwórz VAO i bufory dla wszystkich wymaganych parametrów tkaniny.
			
			Załaduj kernel rozwiązywania kolizji, kalkulacji wektorów normalnych i symulacji tkaniny przy użyciu wybranego modelu.
			
			Utwórz obiekt transformacyjnego sprzężenia zwrotnego dla wszystkich etapów, i odpowiednio dla każdego z nich bufory zwrotne oraz bufory jednorodne.

			\While{m\_running}
			{
				Pobierz wymagane dane z systemu. 
				
				Przypisz wszystkie tablice atrybutów wierzchołków z parametrami tkaniny właściwymi każdemu wierzchołkowi. (\texttt{glBindBuffer(GL\_ARRAY\_BUFFER, ...)}, \texttt{glEnableVertexAttribArray}, \texttt{glVertexAttribPointer})
				
				Użyj kernela obliczeń ruchu tkaniny. (\texttt{glUseKernel})
				
				Ustaw zmienne jednorodne i bufory jednorodne. (\texttt{glBindBufferBase(GL\_UNIFORM\_BUFFER, ...)}, \texttt{glUniform...})
				
				Wyłącz rasteryzer. (\texttt{glEnable(GL\_RASTERIZER\_DISCARD)})
				
				Zwiąż obiekt transformacyjnego sprzężenia zwrotnego. (\texttt{glBindTransformFeedback})
				
				Zwiąż odpowiednie bufory zwrotne. (\texttt{glBindBufferBase(GL\_TRANSFORM\_FEEDBACK\_BUFFER, ...)})
				
				Uruchom transformacyjne sprzężenie zwrotne. (\texttt{glBeginTransformFeedback(GL\_POINTS)})
				
				Rozpocznij obliczenia. (\texttt{glDrawArrays})
				
				Włącz rasteryzer. (\texttt{glDisable(GL\_RASTERIZER\_DISCARD)})
				
				Przełącz identyfikatory buforów odczytu i zapisu.
				
				Użyj kernela rozwiązywania kolizji.
				
				Dokonaj operacji przygotowawczych i uruchamiających obliczenia w podobny sposób.
				
				Przełącz identyfikatory buforów odczytu i zapisu.
				
				Użyj kernela kalkulacji wektorów normalnych.
				
				Dokonaj operacji przygotowawczych i uruchamiających obliczenia w podobny sposób.
				
				Przełącz identyfikatory buforów odczytu i zapisu.
			}
		\end{algorithm}
		
		\begin{algorithm}
			\label{alg_5_2}
			\caption{Symulacja na CPU.}	
			
			Inicjalizuj parametry tkaniny.
			
			\While{m\_running}
			{
				Pobierz wymagane dane z systemu.
				
				Dla każdego wierzchołka oblicz nowe położenie zgodnie z przyjętym modelem symulacji.
				
				Przełącz identyfikatory buforów odczytu i zapisu.
				
				Dla każdego wierzchołka rozwiąż kolizje i przesuń zgodnie z sygnałem z urządzenia wejściowego.
				
				Przełącz identyfikatory buforów odczytu i zapisu.
				
				Dla każdego wierzchołka oblicz nowy wektor normalny.
				
				Zaktualizuj bufor pozycji wierzchołków na GPU. (\texttt{glBufferSubData})
				
				Zaktualizuj bufor wektorów normalnych wierzchołków na GPU.
			}
			
		\end{algorithm}
		
		\begin{algorithm}
			\label{alg_5_3}
			\caption{Symulacja na CPU z użyciem 4 wątków roboczych.}	
			Wątek główny:
			
			\Indp
			
			Inicjalizuj parametry tkaniny.
			
			Utwórz muteksy: trzy dla każdego etapu obliczeń, dla licznika wątków i zmiennej logicznej kończącej obliczenia -- \texttt{m\_threadsRunning} (\texttt{pthread\_mutex\_init})
			
			Zablokuj muteksy odpowiadające etapom obliczeń. (\texttt{pthread\_mutex\_lock})
			
			Utwórz struktury danych dla wątków -- podziel dane tkaniny na 4 części.
			
			Uruchom wątki. (\texttt{pthread\_create})
			
			\While{m\_running}
			{
				Dla dwóch pierwszych etapów obliczeń:
				
				\Indp
					Odblokuj muteks danego etapu.
					
					Czekaj, aż licznik wątków, które ukończyły obliczenia osiągnie wartość liczby wszystkich wątków roboczych.
					
					Zablokuj muteks danego etapu.
					
					Ustaw licznik wątków na zero.
					
					Przełącz identyfikatory buforów odczytu i zapisu.
				\Indm
				
				Odblokuj muteks etapu trzeciego.
				
				Czekaj, aż licznik wątków, które ukończyły obliczenia osiągnie wartość liczby wszystkich wątków roboczych.
				
				Zablokuj muteks etapu trzeciego.
				
				Ustaw licznik wątków na zero.
				
				Zaktualizuj bufor pozycji wierzchołków na GPU. (\texttt{glBufferSubData})
				
				Zaktualizuj bufor wektorów normalnych wierzchołków na GPU.
			}
			
			\Indm
			
			Wątek roboczy:
			
			\While{m\_threadsRunning}
			{
				Czekaj na odblokowanie muteksu etapu 1.
				
				Pobierz wymagane dane z systemu.
				
				Dla każdego przydzielonego wierzchołka, oblicz nowe położenie, zgodnie z ustalonym modelem symulacji.
				
				Inkrementuj licznik wątków, które ukończyły pracę.
				
				Czekaj na odblokowanie muteksu etapu 2.
				
				Dla każdego przydzielonego wierzchołka, rozwiąż kolizje i przesunięcie, zgodnie z sygnałem z urządzenia wejściowego.
				
				Inkrementuj licznik wątków, które ukończyły pracę.
				
				Czekaj na odblokowanie muteksu etapu 3.
				
				Dla każdego przydzielonego wierzchołka, oblicz nowy wektor normalny.
				
				Inkrementuj licznik wątków, które ukończyły pracę.
			}
			
			\Indp
			
			\Indm
		\end{algorithm}
	
		\subsection{Parametry symulacji}
		\label{t:symulacja:dzialanie:parametry}
			
		% lista parametrów z objaśnieniami, proces inicjalizacji paramterów
		
		tba
			
		\subsection{Obliczenia ruchu tkaniny}
		\label{t:symulacja:dzialanie:ruch}
			
		% różnice między MS i PB z punktu widzenia implementacji, listing dla MS, listing dla PB, ograniczenie buforów jednorodnych
		
		tba
		
		\subsection{Rozwiązywanie kolizji}
		\label{t:symulacja:dzialanie:kolizje}
			
		% algorytm, komunikacja z PhysicsManagerem -- struktury i pakowanie tego na GPU
		
		tba
			
		\subsection{Interakcja z użytkownikiem}
		\label{t:symulacja:dzialanie:interakcja}
			
		% po co, co możemy robić, jak to działa, wzory, algorytm
		
		tba
			
		\subsection{Przeliczenie wektorów normalnych}
		\label{t:symulacja:dzialanie:normalne}
			
		% po co, wzór, algorytm
	
		tba
		
	%\section{Budowa i działanie symulatora tkaniny na platformie Windows}	% - ni ma CUDY, będzie to samo	%\label{t:praktyka:symulacjapc}
	
