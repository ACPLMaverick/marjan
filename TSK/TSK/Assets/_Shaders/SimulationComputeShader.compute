// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Advect
#pragma kernel Diffuse
#pragma kernel ApplyForces
#pragma kernel Pressure
#pragma kernel SubtractPressure
#pragma kernel SwapOldToNew
#pragma kernel SwapNewToOld

///////////////////////////////
// Defines

#define THREAD_COUNT 32
#define FORCE_MAX 1.0
#define JACOBI_ITERATIONS 20

#define FCOORD(x, y, w)  x * w + y

///////////////////////////////
// Variables

RWStructuredBuffer<float2> VelocityField;
RWStructuredBuffer<float2> VelocityFieldNew;
RWStructuredBuffer<float> PressureField;
RWStructuredBuffer<float> PressureFieldNew;
RWStructuredBuffer<float2> JacobiHelper;
RWStructuredBuffer<float4> ParticleData;	// r, g - position, b - viscosity, a - mass
float2 DropperPosition;
float2 DropperDirection;
float DropperRadius;
float DropperForceValue;
float DropperForceMultiplier;
float DeltaTime;
float Dx;
float ContainerElasticity;
int Width;

////////////////////////////////
// Aux. functions

inline void Jacobi
	(
		out float2 xNew,
		uint2 coord,
		float alpha,
		float rBeta,
		RWStructuredBuffer<float2> xField,
		float2 b
	)
{
	uint2 cXL = coord + uint2(-1, 0);
	uint2 cXR = coord + uint2(1, 0);
	uint2 cXB = coord + uint2(0, -1);
	uint2 cXT = coord + uint2(0, 1);

	float2 xL = xField[FCOORD(cXL.x, cXL.y, Width)];
	float2 xR = xField[FCOORD(cXR.x, cXR.y, Width)];
	float2 xB = xField[FCOORD(cXB.x, cXB.y, Width)];
	float2 xT = xField[FCOORD(cXT.x, cXT.y, Width)];

	xNew = (xL + xR + xB + xT + alpha * b) * rBeta;
}

inline void Divergence
	(
		out float2 xNew,
		uint2 coord,
		float halfrdx,
		Texture2D<float2> xField
	)
{
	float2 xL = xField[coord + uint2(-1, 0)];
	float2 xR = xField[coord + uint2(1, 0)];
	float2 xB = xField[coord + uint2(0, -1)];
	float2 xT = xField[coord + uint2(0, 1)];

	xNew.x = halfrdx * ((xR.r - xL.r) + (xT.g - xB.g));
	xNew.y = 0.0f;
}

//////////////////////////////
// Kernels

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void Advect (uint3 id : SV_DispatchThreadID)
{
	uint c = FCOORD(id.x, id.y, Width);

	float2 cPos = id.xy;
	float2 cVel = float2(VelocityField[c].y, VelocityField[c].x);
	float2 backPos = cPos - DeltaTime * cVel;
	
	backPos.x = clamp(backPos.x, 0.0f, (float)Width - 1.0f); 
	backPos.y = clamp(backPos.y, 0.0f, (float)Width - 1.0f); 
	
	uint2 tl = uint2(floor(backPos.x), ceil(backPos.y));
	uint2 tr = uint2(ceil(backPos.x), ceil(backPos.y));
	uint2 br = uint2(ceil(backPos.x), floor(backPos.y));
	uint2 bl = uint2(floor(backPos.x), floor(backPos.y));

	float2 nPos = (VelocityField[FCOORD(tl.x, tl.y, Width)] + 
	VelocityField[FCOORD(tr.x, tr.y, Width)] + 
	VelocityField[FCOORD(bl.x, bl.y, Width)] + 
	VelocityField[FCOORD(br.x, br.y, Width)]) / 4.0f;

	if(nPos.x != nPos.x || nPos.y != nPos.y)
		nPos = 0.0f;

    VelocityFieldNew[c] = nPos;
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	uint c = FCOORD(id.x, id.y, Width);

	float visc = ParticleData[c].z;
    float alpha = (Dx * Dx) / (visc * DeltaTime);
	float rBeta = 1.0f / (4.0f + alpha);

	uint2 cXL = clamp(id.xy + uint2(-1, 0), 0, Width - 1);
	uint2 cXR = clamp(id.xy + uint2(1, 0), 0, Width - 1);
	uint2 cXB = clamp(id.xy + uint2(0, -1), 0, Width - 1);
	uint2 cXT = clamp(id.xy + uint2(0, 1), 0, Width - 1);

	float2 xL = VelocityField[FCOORD(cXL.x, cXL.y, Width)];
	float2 xR = VelocityField[FCOORD(cXR.x, cXR.y, Width)];
	float2 xB = VelocityField[FCOORD(cXB.x, cXB.y, Width)];
	float2 xT = VelocityField[FCOORD(cXT.x, cXT.y, Width)];
	float2 xC = VelocityField[c];

	VelocityFieldNew[c] = (xL + xR + xB + xT + alpha * xC) * rBeta;
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void ApplyForces (uint3 id : SV_DispatchThreadID)
{
	uint c = FCOORD(id.x, id.y, Width);

    float2 forceVector = DropperDirection * DropperForceValue * DeltaTime;
	float2 pPos = float2(ParticleData[c].xy);
	float divisor = (pPos.x - DropperPosition.x) * (pPos.x - DropperPosition.x) +
					(pPos.y - DropperPosition.y) * (pPos.y - DropperPosition.y);
	//divisor = max(divisor, 0.0000001f);

	float2 nVel = forceVector * exp(DropperRadius / divisor);
	//nVel.x = clamp(nVel.x, -FORCE_MAX, FORCE_MAX);
	//nVel.y = clamp(nVel.y, -FORCE_MAX, FORCE_MAX);

	nVel = nVel * DropperForceMultiplier * length(DropperDirection) * 10.0f;

	if(nVel.x != nVel.x || nVel.y != nVel.y)
		nVel = 0.0;

    VelocityFieldNew[c].xy = clamp(VelocityField[c].xy + nVel.xy, -FORCE_MAX, FORCE_MAX);
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void Pressure (uint3 id : SV_DispatchThreadID)
{
	uint c = FCOORD(id.x, id.y, Width);

	// calculate params
	float alpha = -(Dx * Dx * 2.0f);
	float rBeta = 0.25f;
	float halfrdx = 1.0f / (2.0f * Dx);

	uint2 cXL = clamp(id.xy + uint2(-1, 0), 0, Width - 1);
	uint2 cXR = clamp(id.xy + uint2(1, 0), 0, Width - 1);
	uint2 cXB = clamp(id.xy + uint2(0, -1), 0, Width - 1);
	uint2 cXT = clamp(id.xy + uint2(0, 1), 0, Width - 1);

	// calculate divergence
	float2 vL = VelocityField[FCOORD(cXL.x, cXL.y, Width)];
	float2 vR = VelocityField[FCOORD(cXR.x, cXR.y, Width)];
	float2 vB = VelocityField[FCOORD(cXB.x, cXB.y, Width)];
	float2 vT = VelocityField[FCOORD(cXT.x, cXT.y, Width)];

	float div = halfrdx * ((vR.x - vL.x) + (vT.y - vB.y));

	// calculate pressure
	float pL = PressureField[FCOORD(cXL.x, cXL.y, Width)];
	float pR = PressureField[FCOORD(cXR.x, cXR.y, Width)];
	float pB = PressureField[FCOORD(cXB.x, cXB.y, Width)];
	float pT = PressureField[FCOORD(cXT.x, cXT.y, Width)];

    PressureFieldNew[c] = (pL + pR + pB + pT + alpha * div) * rBeta;
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void SubtractPressure (uint3 id : SV_DispatchThreadID)
{
	uint c = FCOORD(id.x, id.y, Width);
	
	float halfrdx = 1.0f / (2.0f * Dx);
	uint2 cXL = clamp(id.xy + uint2(-1, 0), 0, Width - 1);
	uint2 cXR = clamp(id.xy + uint2(1, 0), 0, Width - 1);
	uint2 cXB = clamp(id.xy + uint2(0, -1), 0, Width - 1);
	uint2 cXT = clamp(id.xy + uint2(0, 1), 0, Width - 1);

	float pL = PressureField[FCOORD(cXL.x, cXL.y, Width)];
	float pR = PressureField[FCOORD(cXR.x, cXR.y, Width)];
	float pB = PressureField[FCOORD(cXB.x, cXB.y, Width)];
	float pT = PressureField[FCOORD(cXT.x, cXT.y, Width)];

	VelocityFieldNew[c] = float2(
		VelocityField[c].x - halfrdx * (pR - pL), 
		VelocityField[c].y - halfrdx * (pT - pB)
		);
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void SwapOldToNew (uint3 id : SV_DispatchThreadID)
{
	uint c = FCOORD(id.x, id.y, Width);

    VelocityFieldNew[c] = VelocityField[c];
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void SwapNewToOld (uint3 id : SV_DispatchThreadID)
{
	uint c = FCOORD(id.x, id.y, Width);

    VelocityFieldNew[c] = VelocityField[c];
}