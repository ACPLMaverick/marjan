// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Advect
#pragma kernel Diffuse
#pragma kernel ApplyForces
#pragma kernel Project
#pragma kernel Swap

///////////////////////////////
// Defines

#define FORCE_MAX 1.0

///////////////////////////////
// Variables

Texture2D<float2> VelocityField;
RWTexture2D<float2> VelocityFieldNew;
Texture2D<float2> PressureField;
RWTexture2D<float2> PressureFieldNew;

RWTexture2D<float> JacobiHelperX;
RWTexture2D<float> JacobiHelperY;

sampler samplerVelocityField = sampler_state
{
	texture = <VelocityField>;
	MipFilter = Linear;
	MinFilter = Linear;
	MagFilter = Linear;
	AddressU = clamp;
	AddressV = clamp;
};

sampler samplerPressureField = sampler_state
{
	texture = <PressureField>;
	MipFilter = Linear;
	MinFilter = Linear;
	MagFilter = Linear;
	AddressU = clamp;
	AddressV = clamp;
};

// r, g - position, b - viscosity, a - mass
Texture2D<float4> ParticleData;
float2 DropperPosition;
float2 DropperDirection;
float DropperRadius;
float DropperForceValue;
float DropperForceMultiplier;
float DeltaTime;
float Dx;
int Width;
int JacobiIterations;

////////////////////////////////
// Aux. functions

inline void Jacobi
	(
		out float2 xNew,
		uint2 coord,
		float alpha,
		float rBeta,
		RWTexture2D<float> xField,
		RWTexture2D<float> yField,
		float2 b
	)
{
	float2 xL = float2(xField[coord + uint2(-1, 0)], yField[coord + uint2(-1, 0)]);
	float2 xR = float2(xField[coord + uint2(1, 0)], yField[coord + uint2(1, 0)]);
	float2 xB = float2(xField[coord + uint2(0, -1)], yField[coord + uint2(0, -1)]);
	float2 xT = float2(xField[coord + uint2(0, 1)], yField[coord + uint2(0, 1)]);

	xNew = (xL + xR + xB + xT + alpha * b) * rBeta;
}

inline void Divergence
	(
		out float2 xNew,
		uint2 coord,
		float halfrdx,
		Texture2D<float2> xField
	)
{
	float2 xL = xField[coord + uint2(-1, 0)];
	float2 xR = xField[coord + uint2(1, 0)];
	float2 xB = xField[coord + uint2(0, -1)];
	float2 xT = xField[coord + uint2(0, 1)];

	xNew.x = halfrdx * ((xR.r - xL.r) + (xT.g - xB.g));
	xNew.y = 0.0;
}

//////////////////////////////
// Kernels

[numthreads(32,32,1)]
void Advect (uint3 id : SV_DispatchThreadID)
{
	float2 cPos = id.xy;
	float2 cVel = VelocityField[id.xy];
	float2 backPos = cPos - DeltaTime * cVel;
	
	//backPos.x = clamp(backPos.x, 0.0f, (float)Width - 1.0); 
	//backPos.y = clamp(backPos.y, 0.0f, (float)Width - 1.0); 

	float2 nPos = VelocityField.SampleLevel(samplerVelocityField, backPos, 0.0);

    VelocityFieldNew[id.xy] = nPos;
}

[numthreads(32,32,1)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	float visc = ParticleData[id.xy].z;
    float alpha = (Dx * Dx) / (visc * DeltaTime);
	float rBeta = 1.0f / (4.0f + alpha);

	float2 cVal = float2(VelocityField[id.xy].x, VelocityField[id.xy].y);
	JacobiHelperX[id.xy] = cVal.x;
	JacobiHelperY[id.xy] = cVal.y;

	AllMemoryBarrierWithGroupSync();

	for(int i = 0; i < JacobiIterations; ++i)
	{
		Jacobi(id.xy, cVal, alpha, rBeta, JacobiHelperX, JacobiHelperY, float2(JacobiHelperX[id.xy], JacobiHelperY[id.xy]));
		JacobiHelperX[id.xy] = cVal.x;
		JacobiHelperY[id.xy] = cVal.y;

		AllMemoryBarrierWithGroupSync();
	}
	
    VelocityFieldNew[id.xy] = float2(JacobiHelperX[id.xy], JacobiHelperY[id.xy]);

	//VelocityFieldNew[id.xy] = VelocityField[id.xy];
}

[numthreads(32,32,1)]
void ApplyForces (uint3 id : SV_DispatchThreadID)
{
    float2 forceVector = DropperDirection * DropperForceValue * DeltaTime;
	float divisor = (ParticleData[id.xy].x - DropperPosition.x) * (ParticleData[id.xy].x - DropperPosition.x) +
					(ParticleData[id.xy].y - DropperPosition.y) * (ParticleData[id.xy].y - DropperPosition.y);
	divisor = max(divisor, 0.0000001);

	float2 nVel = forceVector * exp(DropperRadius / divisor);
	nVel.x = clamp(nVel.x, -FORCE_MAX, FORCE_MAX);
	nVel.y = clamp(nVel.y, -FORCE_MAX, FORCE_MAX);

	nVel = nVel * DropperForceMultiplier;

    VelocityFieldNew[id.xy].xy = clamp(VelocityField[id.xy].xy + nVel.xy, -FORCE_MAX, FORCE_MAX);
}

[numthreads(32,32,1)]
void Project (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    VelocityFieldNew[id.xy] = VelocityField[id.xy];
}

[numthreads(32,32,1)]
void Swap (uint3 id : SV_DispatchThreadID)
{
    VelocityFieldNew[id.xy] = VelocityField[id.xy];
}