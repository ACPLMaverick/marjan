// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Advect
#pragma kernel Diffuse
#pragma kernel ApplyForces
#pragma kernel Project
#pragma kernel SwapOldToNew
#pragma kernel SwapNewToOld
#pragma kernel Initalize

///////////////////////////////
// Defines

#define THREAD_COUNT 32
#define FORCE_MAX 1.0
#define JACOBI_ITERATIONS 20

///////////////////////////////
// Variables

RWStructuredBuffer<float2> VelocityField;
RWStructuredBuffer<float2> VelocityFieldNew;
RWStructuredBuffer<float> PressureField;
RWStructuredBuffer<float> PressureFieldNew;
RWStructuredBuffer<float2> JacobiHelper;
RWStructuredBuffer<float4> ParticleData;	// r, g - position, b - viscosity, a - mass
float2 DropperPosition;
float2 DropperDirection;
float DropperRadius;
float DropperForceValue;
float DropperForceMultiplier;
float DeltaTime;
float Dx;
int Width;

////////////////////////////////
// Aux. functions

inline void Jacobi
	(
		out float2 xNew,
		uint2 coord,
		float alpha,
		float rBeta,
		RWTexture2D<float> xField,
		RWTexture2D<float> yField,
		float2 b
	)
{
	float2 xL = float2(xField[coord + uint2(-1, 0)], yField[coord + uint2(-1, 0)]);
	float2 xR = float2(xField[coord + uint2(1, 0)], yField[coord + uint2(1, 0)]);
	float2 xB = float2(xField[coord + uint2(0, -1)], yField[coord + uint2(0, -1)]);
	float2 xT = float2(xField[coord + uint2(0, 1)], yField[coord + uint2(0, 1)]);

	xNew = (xL + xR + xB + xT + alpha * b) * rBeta;
}

inline void Divergence
	(
		out float2 xNew,
		uint2 coord,
		float halfrdx,
		Texture2D<float2> xField
	)
{
	float2 xL = xField[coord + uint2(-1, 0)];
	float2 xR = xField[coord + uint2(1, 0)];
	float2 xB = xField[coord + uint2(0, -1)];
	float2 xT = xField[coord + uint2(0, 1)];

	xNew.x = halfrdx * ((xR.r - xL.r) + (xT.g - xB.g));
	xNew.y = 0.0;
}

//////////////////////////////
// Kernels

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void Advect (uint3 id : SV_DispatchThreadID)
{
	uint c = id.x * Width + id.y;

	float2 cPos = id.xy;
	float2 cVel = float2(VelocityField[c].y, VelocityField[c].x);
	float2 backPos = cPos - DeltaTime * cVel;
	
	backPos.x = clamp(backPos.x, 0.0f, (float)Width - 1.0); 
	backPos.y = clamp(backPos.y, 0.0f, (float)Width - 1.0); 
	
	uint2 tl = uint2(floor(backPos.x), ceil(backPos.y));
	uint2 tr = uint2(ceil(backPos.x), ceil(backPos.y));
	uint2 br = uint2(ceil(backPos.x), floor(backPos.y));
	uint2 bl = uint2(floor(backPos.x), floor(backPos.y));

	uint ftl = tl.x * Width + tl.y;
	uint ftr = tr.x * Width + tr.y;
	uint fbl = bl.x * Width + bl.y;
	uint fbr = br.x * Width + br.y;

	float2 nPos = (VelocityField[ftl] + 
	VelocityField[ftr] + 
	VelocityField[fbr] + 
	VelocityField[fbl]) / 4.0;


	if(nPos.x != nPos.x || nPos.y != nPos.y)
		nPos = 0.0;

    VelocityFieldNew[c] = nPos;
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	uint c = id.x * Width + id.y;
/*
	float visc = ParticleData[id.xy].z;
    float alpha = (Dx * Dx) / (visc * DeltaTime);
	float rBeta = 1.0f / (4.0f + alpha);

	float2 cVal = float2(VelocityField[id.xy].x, VelocityField[id.xy].y);
	JacobiHelperX[id.xy] = cVal.x;
	JacobiHelperY[id.xy] = cVal.y;

	//AllMemoryBarrierWithGroupSync();

	[unroll]
	for(int i = 0; i < JACOBI_ITERATIONS; ++i)
	{
		Jacobi(id.xy, cVal, alpha, rBeta, JacobiHelperX, JacobiHelperY, float2(JacobiHelperX[id.xy], JacobiHelperY[id.xy]));
		JacobiHelperX[id.xy] = cVal.x;
		JacobiHelperY[id.xy] = cVal.y;

		//AllMemoryBarrierWithGroupSync();
	}
	*/
    //VelocityFieldNew[id.xy] = float2(JacobiHelperX[id.xy], JacobiHelperY[id.xy]);

	VelocityFieldNew[c] = float2(VelocityField[c].x, VelocityField[c].y);
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void ApplyForces (uint3 id : SV_DispatchThreadID)
{
	uint c = id.x * Width + id.y;

    float2 forceVector = DropperDirection * DropperForceValue * DeltaTime;
	float2 pPos = float2(ParticleData[c].xy);
	float divisor = (pPos.x - DropperPosition.x) * (pPos.x - DropperPosition.x) +
					(pPos.y - DropperPosition.y) * (pPos.y - DropperPosition.y);
	divisor = max(divisor, 0.0000001);

	float2 nVel = forceVector * exp(DropperRadius / divisor);
	nVel.x = clamp(nVel.x, -FORCE_MAX, FORCE_MAX);
	nVel.y = clamp(nVel.y, -FORCE_MAX, FORCE_MAX);

	nVel = nVel * DropperForceMultiplier;

    VelocityFieldNew[c].xy = clamp(VelocityField[c].xy + nVel.xy, -FORCE_MAX, FORCE_MAX);
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void Project (uint3 id : SV_DispatchThreadID)
{
	uint c = id.x * Width + id.y;

    VelocityFieldNew[c] = VelocityField[c];
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void SwapOldToNew (uint3 id : SV_DispatchThreadID)
{
	uint c = id.x * Width + id.y;

    VelocityFieldNew[c] = VelocityField[c];
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void SwapNewToOld (uint3 id : SV_DispatchThreadID)
{
	uint c = id.x * Width + id.y;

    VelocityFieldNew[c] = VelocityField[c];
}

[numthreads(THREAD_COUNT,THREAD_COUNT,1)]
void Initialize (uint3 id : SV_DispatchThreadID)
{
	uint c = id.x * Width + id.y;

    VelocityFieldNew[c] = 0.0;
	PressureFieldNew[c] = 0.0;
}